    
    template<
    typename tkey,
    typename tvalue>
class B_plus_tree final
{
    struct key_value_ptr_pair
    {
        tkey key;
        tvalue *value;
    };

    struct node
    {   
        size_t virtual_size;
        key_value_ptr_pair *kvp_array;
        node **subtrees;
    };

    size_t _t;
    node *_root;
    std::function<int(tkey const &, tkey const &)> _comparer;


    bool dispose(
        tkey const &key)
    {
        //найден элемент
        auto path = find_path(key);
        
        if (path.empty() || path.top().second < 0)
            return false;
        
        node *cur = *path.top().first;
        size_t index = path.top().second;
        
        bool need_restructure = index == 0;
        tkey disposed_key = cur->kvp_array[index].key;
        
        for (size_t i = index + 1; i < cur->virtual_size; ++i)
        {
            std::swap(cur->kvp_array[i - 1], cur->kvp_array[i]);
        }
        // destruct
        
        cur->virtual_size--;
        
        while (cur->virtual_size < _t - 1)
        {
            path.pop();
            
            if (path.empty())
            {
                if (cur->virtual_size == 0)
                {
                    _root = cur->subtrees[0];
                    delete cur;
                }
                
                return true;
            }
            
            node *parent = *path.top().first;
            int sub_index = path.top().second;
            size_t index = -sub_index - 1;
            
            bool is_leaf = cur->subtrees[0] == nullptr;
            
            bool is_left_brother_exists = index > 0;
            bool is_right_brother_exists = index < parent->virtual_size;
            
            bool can_take_from_left = is_left_brother_exists && (parent->subtrees[index - 1]->virtual_size > _t - 1);
            bool can_take_from_right = is_right_brother_exists && (parent->subtrees[index + 1]->virtual_size > _t - 1);
            
            if (can_take_from_left)
            {
                node *left_brother = parent->subtrees[index - 1];
                
                if (is_leaf)
                {
                    for (size_t i = cur->virtual_size; i > 1; ++i)
                    {
                        std::swap(cur->kvp_array[i], cur->kvp_array[i-1]);
                    }
                    
                    std::swap(cur->kvp_array[0], left_brother->kvp_array[left_brother->virtual_size - 1]);
                    // destruct node?
                }
                else
                {
                    for (size_t i = cur->virtual_size; i > 1; ++i)
                    {
                        std::swap(cur->kvp_array[i], cur->kvp_array[i-1]);
                        std::swap(cur->subtrees[i+1], cur->subtrees[i]);
                    }
                    std::swap(cur->subtrees[0], cur->subtrees[1]);
                    
                    std::swap(cur->kvp_array[0], parent->kvp_array[index - 1]);
                    std::swap(parent->kvp_array[index - 1], left_brother->kvp_array[left_brother->virtual_size - 1]);
                    std::swap(cur->subtrees[0], left_brother->subtrees[left_brother->virtual_size]);
                }
                left_brother->virtual_size--;
                cur->virtual_size++;
            }
            else if (can_take_from_right)
            {
                node *right_brother = parent->subtrees[index + 1];
                
                if (is_leaf)
                {
                    std::swap(cur->kvp_array[cur->virtual_size], right_brother->kvp_array[0]);
                    
                    for (size_t i = 1; i < right_brother->virtual_size; ++i)
                    {
                        std::swap(right_brother->kvp_array[i-1], right_brother->kvp_array[i]);
                    }
                    
                    parent->kvp_array[index] = right_brother->kvp_array[0];
                }
                else
                {
                    std::swap(cur->kvp_array[cur->virtual_size], parent->kvp_array[index]);
                    std::swap(parent->kvp_array[index], right_brother->kvp_array[0]);
                    std::swap(cur->subtrees[cur->virtual_size + 1], right_brother->subtrees[0]);
                    
                    for (size_t i = 1; i < right_brother->virtual_size; ++i)
                    {
                        std::swap(right_brother->kvp_array[i-1], right_brother->kvp_array[i]);
                        std::swap(right_brother->subtrees[i-1], right_brother->subtrees[i]);
                    }
                    std::swap(cur->subtrees[right_brother->virtual_size - 1], cur->subtrees[right_brother->virtual_size]);
                }
                
                right_brother->virtual_size--;
                cur->virtual_size++;
            }
            else
            {
                if (is_left_brother_exists)
                {
                    merge(parent, index - 1, is_leaf);
                }
                else
                {
                    merge(parent, index, is_leaf);
                }
            }
            
            if (is_leaf && need_restructure)
            {
                update_structure(cur, path, disposed_key);
                need_restructure = false;
            }
            
            if (can_take_from_left || can_take_from_right)
            {
                return true;
            }
            cur = parent;
        }
        if (need_restructure)
        {
            update_structure(cur, path, disposed_key);
        }
        return true;
    }



        bool insert(
        tkey const &key,
        tvalue &&value)
    {
        auto path = find_path(key);
        
        if (path.empty())
        {
            _root = new node(_t);
            _root->kvp_array[0] = key_value_ptr_pair(key, std::move(value));
            _root->virtual_size++;
            return true;
        }
        
        auto **cur = path.top().first;
        auto index = path.top().second;
        
        if (index >= 0)
            return false;
        
        index = -index - 1;
        (*cur)->kvp_array[(*cur)->virtual_size] = key_value_ptr_pair(key, std::move(value));
        
        for (size_t i = (*cur)->virtual_size; i > index; --i)
            std::swap((*cur)->kvp_array[i], (*cur)->kvp_array[i-1]);
        
        (*cur)->virtual_size++;
        
        while ((*cur)->virtual_size == 2 * _t)
        {
            auto [kvp, right] = split(*cur);
            path.pop();
            
            if (path.empty())
            {
                node* tmp = *cur;
                
                _root = new node(_t);
                _root->kvp_array[0] = std::move(kvp);
                _root->virtual_size++;
                
                _root->subtrees[0] = tmp;
                _root->subtrees[1] = right;
                
                return true;
            }
            
            cur = path.top().first;
            index = -path.top().second - 1;
            
            (*cur)->kvp_array[(*cur)->virtual_size] = std::move(kvp);
            (*cur)->subtrees[(*cur)->virtual_size + 1] = right;
            
            for (size_t i = (*cur)->virtual_size; i > index; --i)
            {
                std::swap((*cur)->kvp_array[i], (*cur)->kvp_array[i-1]);
                std::swap((*cur)->subtrees[i+1], (*cur)->subtrees[i]);
            }
            (*cur)->virtual_size++;
        }
        return true;
    }







    template<
        typename tkey,
        typename tvalue>
void b_tree<tkey, tvalue>::insert_inner(
        typename associative_container<tkey, tvalue>::key_value_pair &&kvp)
{
    auto path = this->find_path(kvp.key);
    auto *node = *path.top().first;
    if (node == nullptr && path.size() == 1)
    {
        typename search_tree<tkey ,tvalue>::common_node *new_node;
        *path.top().first = new_node = this->create_node(_t);
        allocator::construct(new_node->keys_and_values, std::move(kvp));
        ++new_node->virtual_size;
        return;
    }
    if (path.top().second >= 0)
    {
        if (_insert_strategy == insertion_of_existent_key_attempt_strategy::throw_an_exception) throw std::logic_error("duplicate key");
        else
        {
            int index = path.top().second;
            node->keys_and_values[index].value = kvp.value;
            return;
        }
    }
    size_t subtree_index = -path.top().second - 1;
    typename search_tree<tkey, tvalue>::common_node *right_subtree = nullptr;
    while (true)
    {
        if (node->virtual_size < get_max_keys_count())
        {
            this->node_insert(node, std::move(kvp), subtree_index, right_subtree);
            return;
        }

        auto res = this->node_split(node, std::move(kvp), subtree_index, right_subtree);
        right_subtree = res.first;
        kvp = std::move(res.second);

        if (path.size() == 1)
        {
            typename search_tree<tkey, tvalue>::common_node *new_root = this->create_node(_t);
            new_root->virtual_size = 1;
            allocator::construct(new_root->keys_and_values, std::move(kvp));
            new_root->subtrees[0] = node;
            new_root->subtrees[1] = right_subtree;
            *path.top().first = new_root;
            return;
        }

        path.pop();
        node = *path.top().first;
        subtree_index = -path.top().second - 1;
    }
}




[[nodiscard]] void *allocator_boundary_tags::allocate(
    size_t value_size,
    size_t values_count)
{
    std::lock_guard<std::mutex> mutex_guard(get_mutex());

    auto requested_size = value_size * values_count;

    allocator_with_fit_mode::fit_mode fit_mode = get_fit_mode();
    auto block_meta_size = sizeof(allocator*) + 2 * sizeof(void*) + sizeof(size_t);

    void * prev_occupied_block = nullptr;
    void * current_occupied_block = get_first_occupied_block();
    void * target_block = nullptr;
    size_t prev_size = 0;

    void * target_prev = nullptr;
    void * target_next = nullptr;

    size_t available_block_size = get_memory_size();
    void * current_available_block;

    // all memory is free
    if (current_occupied_block == nullptr && available_block_size >= requested_size + block_meta_size)
    {
        target_block = get_first_block();
    }

    while (current_occupied_block != nullptr)
    {
        if (prev_occupied_block == nullptr) current_available_block = get_first_block();
        else current_available_block = reinterpret_cast<unsigned char *>(prev_occupied_block) + block_meta_size + get_block_size(prev_occupied_block);

        if (current_available_block != current_occupied_block)
        {
            available_block_size = reinterpret_cast<unsigned char*>(current_occupied_block) - reinterpret_cast<unsigned char *>(current_available_block);
            if (available_block_size >= requested_size + block_meta_size)
            {
                if (fit_mode == allocator_with_fit_mode::fit_mode::first_fit)
                {
                    target_block = current_available_block;
                    prev_size = available_block_size;
                    target_prev = prev_occupied_block;
                    target_next = current_occupied_block;
                    break;
                }
            }
        }
        prev_occupied_block = current_occupied_block;
        current_occupied_block = get_next_block(current_occupied_block);
    }
    if (current_occupied_block == nullptr && prev_occupied_block != nullptr && prev_occupied_block != get_end())
    {
        current_available_block = reinterpret_cast<unsigned char *>(prev_occupied_block) + block_meta_size + get_block_size(prev_occupied_block);
        available_block_size = reinterpret_cast<unsigned char*>(get_end()) - reinterpret_cast<unsigned char *>(current_available_block);
        if (available_block_size >= requested_size + block_meta_size)
        {
            if (fit_mode == allocator_with_fit_mode::fit_mode::first_fit && target_block == nullptr)
            {
                target_block = current_available_block;
                prev_size = available_block_size;
                target_prev = prev_occupied_block;
                target_next = current_occupied_block;
            }
        }
    }
}

void allocator_boundary_tags::deallocate(void *at)
{

    std::string block_info_array = get_block_info(at);
    auto meta = 2 * sizeof(void*) + sizeof(size_t) + sizeof(allocator*);

    unsigned char * block = reinterpret_cast<unsigned char *>(at) - meta;
    if (get_block_allocator(block) != this)
        throw std::logic_error(error);

    void * prev_block = get_prev_block(block);
    void * next_block =  get_next_block(block);

    connect_blocks(prev_block, next_block);

    clear_block(block);
}


[[nodiscard]] void *allocator_buddies_system::allocate(
    size_t value_size,
    size_t values_count)
{
    std::lock_guard<std::mutex> lock(get_mutex());

    auto requested_size = value_size * values_count + get_occupied_block_meta_size();

    unsigned char degree = get_degree(requested_size);
    unsigned char available_meta_degree = get_degree(get_available_block_meta_size());
    unsigned char occupied_meta_degree = get_degree(get_occupied_block_meta_size())
;
    if (degree < (available_meta_degree > occupied_meta_degree ? available_meta_degree : occupied_meta_degree))
    {
        degree = (available_meta_degree > occupied_meta_degree ? available_meta_degree : occupied_meta_degree);
    }

    if (requested_size > get_available_memory())
    {
        throw std::bad_alloc{};
    }

    allocator_with_fit_mode::fit_mode fit_mode = get_fit_mode();

    void * target = nullptr;

    void * current = get_first_available_block();
    void * previous = nullptr;

    if (fit_mode == allocator_with_fit_mode::fit_mode::first_fit)
    {
        while (current)
        {
            if (abs(get_block_degree(current)) >= degree)
            {
                target = current;
                break;
            }
            current = get_next_block(current);
        }
    }

    if (!target)
        throw std::bad_alloc();

    target = split(target, degree);

    decrease_available_space(requested_size);

    return reinterpret_cast<unsigned char *>(target) + get_occupied_block_meta_size();
}


void allocator_buddies_system::deallocate(
    void *at)
{
    std::lock_guard<std::mutex> lock(get_mutex());

    void * block = reinterpret_cast<unsigned char*>(at) - get_occupied_block_meta_size();
    // block info

    if (get_occupied_block_allocator_beginning(block) != get_beginning_of_memory())
    {
        throw std::logic_error(error);
    }

    merge(block, reinterpret_cast<unsigned char *>(_trusted_memory) + get_allocator_meta_size() + (1 << get_degree(get_available_memory())));

    increase_available_space(1 << abs(get_block_degree(block)));
}


[[nodiscard]] void *allocator_red_black_tree::allocate(
    size_t value_size,
    size_t values_count)
{
    std::lock_guard<std::mutex> lock(get_mutex());

    size_t requested_memory = value_size * values_count;

    void * target;

    switch (get_fit_mode())
    {
        case allocator_with_fit_mode::fit_mode::first_fit:
			target = get_first_fit(requested_memory);
			break;
		case allocator_with_fit_mode::fit_mode::the_best_fit:
			target = get_best_fit(requested_memory);
			break;
		case allocator_with_fit_mode::fit_mode::the_worst_fit:
			target = get_worst_fit(requested_memory);
			break;
    }

    if (!target)
    {
        throw std::bad_alloc();
    }

    remove_block(target);

    get_byte_occupied_color(target).is_occupied = true;
    get_parent(target) = _trusted_memory;
    size_t block_size = get_block_size(target, _trusted_memory);

    if (block_size < requested_memory + get_free_block_meta_size())
	{
		requested_memory = block_size;
	}
    else
    {
        void* new_target = reinterpret_cast<unsigned char*>(target) + get_occupied_block_meta_size() + requested_memory;

		get_next(new_target) = get_next(target);
		get_back(new_target) = target;
		get_next(target) = new_target;

		if (get_next(new_target)) get_back(get_next(new_target)) = new_target;
		get_byte_occupied_color(new_target).is_occupied = false;
		get_parent(new_target) = nullptr;

		insert_block(new_target);
    }

	return reinterpret_cast<unsigned char*>(target) + get_occupied_block_meta_size();
}

void allocator_red_black_tree::deallocate(
    void *at)
{
    // Защита от конкурентного доступа к ресурсам с использованием мьютекса
    std::lock_guard<std::mutex> lock(get_mutex());

    // Получение указателя на блок памяти, по которому производится deallocation
    void * block_ptr = reinterpret_cast<unsigned char*>(at) - get_occupied_block_meta_size();

    // Проверка, что блок памяти принадлежит данному экземпляру аллокатора
    if (get_parent(block_ptr) != _trusted_memory)
        throw std::logic_error("Invalid allocator");

    // Установка флага занятости блока памяти в false
    get_byte_occupied_color(block_ptr).is_occupied = false;

    // Если предыдущий блок памяти свободен, объединить его с текущим блоком
    if (get_back(block_ptr) && !get_byte_occupied_color(get_back(block_ptr)).is_occupied)
    {
        void* tmp = block_ptr;
        block_ptr = get_back(block_ptr);
        remove_block(block_ptr);
        get_next(block_ptr) = get_next(tmp);
        if (get_next(block_ptr)) get_back(get_next(block_ptr)) = block_ptr;
    }

    // Если следующий блок памяти свободен, объединить его с текущим блоком
    if (get_next(block_ptr) && !get_byte_occupied_color(get_next(block_ptr)).is_occupied)
    {
        void* tmp = get_next(block_ptr);
        remove_block(tmp);
        get_next(block_ptr) = get_next(tmp);
        if (get_next(block_ptr)) get_back(get_next(block_ptr)) = block_ptr;
    }

    // Вставка (или обновление) блока памяти в структуру управления памятью
    insert_block(block_ptr);
}

[[nodiscard]] void *allocator_sorted_list::allocate(size_t value_size, size_t values_count)
{
    std::lock_guard<std::mutex> mutex_guard(get_mutex());

    auto requested_size = value_size * values_count;
    if (requested_size < sizeof(void*))
    {
        requested_size = sizeof(void*);
    }
    allocator_with_fit_mode::fit_mode fit_mode = get_fit_mode();

    auto meta_size = sizeof(size_t) + sizeof(allocator*);
    auto result_size = meta_size + requested_size;

    size_t available_memory = 0;

    void * block = nullptr;
    void * prev_target = nullptr;
    void * next_target = nullptr;
    size_t prev_size = 0;

    void * current = get_first_available_block();
    void * previous = nullptr;

    get_available_block_via_fit_mode(fit_mode, )

    if (block == nullptr)
    {
        error_with_guard(get_typename() + " Cannot allocate block\n");
        throw std::bad_alloc();
    }

    auto blocks_sizes_difference = get_available_block_size(block) - requested_size;
    if (blocks_sizes_difference > 0 && blocks_sizes_difference < meta_size)
    {
        requested_size += blocks_sizes_difference;
        result_size = requested_size + meta_size;
    }
    else if (blocks_sizes_difference > 0) // осталось пространство
    {
        void ** new_next = reinterpret_cast<void**>(reinterpret_cast<unsigned char *>(block) + result_size);
        *reinterpret_cast<size_t*>(new_next + 1) = blocks_sizes_difference - sizeof(void*) - sizeof(size_t);

        if (new_next + blocks_sizes_difference != next_target) *new_next = next_target; // если справа занятый
        else merge_blocks(new_next, 0, next_target); // если справа свободный

        if (prev_target != nullptr)
        {
            void **next_block_adress = reinterpret_cast<void **>(prev_target);
            *next_block_adress = new_next;
        }
        else set_first_available_block(new_next);
    }

    void ** prev_adress = reinterpret_cast<void**>(block);
    prev_adress = nullptr;
    
    size_t * prev_size_ptr = reinterpret_cast<size_t*>(prev_adress + 1);
    prev_size_ptr = nullptr;

    size_t * size = reinterpret_cast<size_t*>(block);
    *size = requested_size;

    *reinterpret_cast<allocator**>(size + 1) = this;

    void * result_block = reinterpret_cast<unsigned char *>(block) + meta_size;

    return result_block;
}

void allocator_sorted_list::deallocate(void *at)
{
    std::lock_guard<std::mutex> mutex_guard(get_mutex());

    size_t meta_size = sizeof(allocator*) + sizeof(size_t);

    size_t available_memory = 0;

    void * block = reinterpret_cast<unsigned char *>(at) - meta_size;
    size_t block_size = get_occupied_block_size(block);
    
    if (get_occupied_block_allocator(block) != this)
        throw std::logic_error(error);

    void * current_available = get_first_available_block();
    void * previous_available = nullptr;
    void * next_available = nullptr;
      
    while (current_available != nullptr) // идем по списку свободных
    { 
        available_memory += get_available_block_size(current_available);
        void * current_occupied;
        if ((previous_available == nullptr && current_available != get_first_block()) || current_available == get_first_block()) current_occupied = get_first_block();
        else current_occupied = reinterpret_cast<unsigned char *>(previous_available) + get_available_block_size(previous_available) + sizeof(void*) + sizeof(size_t);

        while (current_occupied != current_available)
        {
            size_t occupied_size = get_occupied_block_size(current_occupied);

            if (current_occupied == block) break;
            current_occupied = reinterpret_cast<unsigned char *>(current_occupied) + sizeof(size_t) + sizeof(allocator*) + occupied_size;
        }
        if (current_occupied == block) break; // нашли блок
        previous_available = current_available;
        current_available = get_available_block_next_block_address(current_available);
    }

    if (block == get_first_block()) // если блок в начале
    {
        if (reinterpret_cast<unsigned char *>(block) + block_size + meta_size == current_available) // справа свободный
        {
            merge_blocks(block, 1, current_available);
        }
        else // справа занятый
        {
            size_t * old_size_ptr = reinterpret_cast<size_t*>(block);
            old_size_ptr = nullptr;
            void ** new_adress_ptr = reinterpret_cast<void**>(block);
            *new_adress_ptr = current_available;
            *reinterpret_cast<size_t*>(new_adress_ptr + 1) = block_size;
        }
        set_first_available_block(block);
        return;
    }
    if (current_available == reinterpret_cast<unsigned char *>(block) +
    sizeof(size_t) + sizeof(allocator*) + block_size && current_available != nullptr) // если справа свободный
    {
        // сначала мерж с правым
        merge_blocks(block, 1, current_available);

        //меняем указатель у левого
        if (previous_available != nullptr)
        {
            *reinterpret_cast<void**>(previous_available) = block;

            if (reinterpret_cast<unsigned char *>(previous_available) + sizeof(size_t) + 
            sizeof(void*) + get_available_block_size(previous_available) == block) // если слева свободный
            {
                // мержим с левым
                merge_blocks(previous_available, 0, block);
            }
        }
        else set_first_available_block(block);
    }
    else if (current_available == reinterpret_cast<unsigned char *>(block) + sizeof(size_t) + 
    sizeof(allocator*) + block_size && current_available == nullptr) // если справа конец
    {
        size_t * old_size = reinterpret_cast<size_t*>(block);
        old_size = nullptr;
        void ** new_adress = reinterpret_cast<void**>(block);
        *new_adress = nullptr;
        *reinterpret_cast<size_t*>(new_adress + 1) = block_size;

        //меняем указатель у левого
        *reinterpret_cast<void**>(previous_available) = block;

        if (reinterpret_cast<unsigned char *>(previous_available) + sizeof(size_t) + 
        sizeof(void*) + get_available_block_size(previous_available) == block) // если слева свободный
        {
            merge_blocks(previous_available, 0, block);
        }
    }
    else // если справа занятый
    {
        size_t * old_size = reinterpret_cast<size_t*>(block);
        old_size = nullptr;
        void ** new_adress = reinterpret_cast<void**>(block);

        *new_adress = current_available;
        *reinterpret_cast<size_t*>(new_adress + 1) = block_size;
        //меняем указатель у левого
        if (previous_available != nullptr)
        {
            *reinterpret_cast<void**>(previous_available) = block;
            if (reinterpret_cast<unsigned char *>(previous_available) + sizeof(size_t) + 
            sizeof(void*) + get_available_block_size(previous_available) == block) // если слева свободный
            {
                merge_blocks(previous_available, 0, block);
            }
        }
        else set_first_available_block(block);
    }
}
